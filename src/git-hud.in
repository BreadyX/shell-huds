#! /usr/bin/env python3
"""Format a quick summary about the current git repository and print it to
standard output"""

import os
import sys
import argparse
import subprocess
import re

NAME = "git-hud"
VERSION = "@version@"
DESCRIPTION = ("Format a quick summary about the current git repository and "
               "print it to standard output.\n")
EPILOG = ("If the environment variable GIT_HUD_GLYPH is set, the script will "
          "use unicode glyphs. The variable is, however, ignored if a tty is "
          "used.")
VERSION_DIALOG = ("{} version {}\n"
                  "Written by BreadyX, contacts:\n"
                  "\tGitHub repo: @repo_url@")
VERSION_HELP = "show info about version"

if ('GIT_HUD_GLYPH' in os.environ) and (not os.environ['TERM'] == 'linux'):
    BRANCH_GLYPH = ''
    AHEAD_GLYPH = '↑'
    BEHIND_GLYPH = '↓'
else:
    BRANCH_GLYPH = 'branch'
    AHEAD_GLYPH = 'ahead '
    BEHIND_GLYPH = 'behind '

EMPTY_REPO = "## No commits yet on master"

def main():
    """Main function"""
    args = setup_args()
    if args.version is True:
        print(VERSION_DIALOG.format(NAME, VERSION))
        sys.exit()

    git_dir = get_root_dir()
    if git_dir is None:
        sys.exit()
    prompt = construct_prompt(git_dir)
    print(prompt)
    sys.exit()

def setup_args():
    """Return namespace with parsed args"""
    parser = argparse.ArgumentParser(prog=NAME, description=DESCRIPTION,
                                     epilog=EPILOG)
    parser.add_argument('-v', '--version', action='store_true',
                        help=VERSION_HELP)
    return parser.parse_args()

def get_root_dir():
    """Get repo root directory"""
    try:
        proc = subprocess.run(["git", "rev-parse", "--show-toplevel"], text=True,
                              check=True, stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        return proc.stdout.strip()
    except subprocess.CalledProcessError:
        return None

def construct_prompt(root_dir):
    """Format prompt"""
    repo_info = get_repo_info()
    if repo_info is None:
        return ""

    branch = get_branch(repo_info)
    ahead, behind = get_ahead_behind(repo_info)
    latest_commit = get_latest_commit()
    unstaged = get_unstaged(repo_info)
    staged = get_staged(repo_info)
    untracked = get_untracked(repo_info)
    unmerged = get_unmerged(repo_info)
    stashed = get_stashed(root_dir)

    prompt = (f'{BRANCH_GLYPH} {branch} ({latest_commit});'
              f' {AHEAD_GLYPH}{ahead} {BEHIND_GLYPH}{behind};'
              f' ({staged}{unstaged}{untracked}{unmerged}{stashed})')
    return prompt

def get_repo_info():
    """Return output of git status --porcelain --branch"""
    try:
        proc = subprocess.run(["git", "status", "--porcelain", "--branch"],
                              check=True, text=True, stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        return proc.stdout.strip()
    except subprocess.CalledProcessError:
        return None

def get_branch(repo_info):
    """Extract branch from repo_info (obtained from get_repo_info)"""
    first_line = repo_info.splitlines()[0]
    branch = ""
    if first_line == EMPTY_REPO:
        return "???"
    branch = first_line.split()[1]  # ex: branch...origin
    branch = branch.split("...")[0] # ex: branch
    return branch

def get_ahead_behind(repo_info):
    """Extract from repo_info number of commits ahead/behind remote"""
    ahead = 0
    behind = 0
    first_line = repo_info.splitlines()[0]
    ahead_behind_match = re.search(r'\[.*\]', first_line) # [ahead 1 behind 1]
    if ahead_behind_match is None:
        return ahead, behind
    ahead_behind_str = ahead_behind_match.group(0)
    ahead_match = re.search(r'(?<=ahead) +[0-9]+', ahead_behind_str) # ' 1'
    behind_match = re.search(r'(?<=behind) +[0-9]+', ahead_behind_str) # ' 1'
    if ahead_match is not None:
        ahead_str = ahead_match.group(0).strip()
        ahead = int(ahead_str)
    if behind_match is not None:
        behind_str = behind_match.group(0).strip()
        behind = int(behind_str)
    return ahead, behind

def get_latest_commit():
    """Get latest commit short hash"""
    try:
        proc = subprocess.run(["git", "rev-parse", "HEAD"], text=True, check=True,
                              stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        return proc.stdout.strip()[0:7]
    except subprocess.CalledProcessError:
        return '???'

def get_unstaged(repo_info):
    """Extract from repo_info using regex if there are unstaged changes and
    return corresponding glyph"""
    unstaged = re.findall(r'(?m)^.[DMARC]', repo_info)
    if unstaged:
        return '*'
    return ''

def get_staged(repo_info):
    """Extract from repo_info using regex if there are staged changes and
    return corresponding glyph"""
    unstaged = re.findall(r'(?m)^[DMARC].', repo_info)
    if unstaged:
        return '+'
    return ''

def get_untracked(repo_info):
    """Extract from repo_info using regex if there are untracked files and
    return corresponding glyph"""
    untracked = re.findall(r'(?m)^\?\?', repo_info)
    if untracked:
        return '?'
    return ''

def get_unmerged(repo_info):
    """Extract from repo_info using regex if there are merge conflicts and
    return corresponding glyph"""
    unmerged = re.findall(r'(?m)^[DAU]{2}', repo_info)
    if unmerged:
        return '!'
    return ''

def get_stashed(git_root_dir):
    """Extract from repo_info using regex if there are stashed changes and
    return corresponding glyph"""
    stash_location = os.path.join(git_root_dir, '.git/refs/stash')
    if os.path.isfile(stash_location):
        return '$'
    return ''

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        pass
